#!/usr/bin/env perl

use utf8;
binmode STDOUT, ":utf8";

package Banshee::LastFm::Sync;

use Data::Dump;

use common::sense;
use Net::LastFMAPI;
use Data::Types qw(:int);
use DBI;
use Try::Tiny;
use Term::ProgressBar;
use File::Copy;
use File::HomeDir;
use Moose;
use DateTime::Format::DateParse;
use DateTime::Format::Epoch;
use DateTime::TimeZone;
use Config::Simple;
use Data::Dumper;


with 'MooseX::Getopt';

has key => ( is => "rw", isa => "Str", required => 0, default => "b25b959554ed76058ac220b7b2e0a026" );
has username => ( is => "rw", isa => "Str", required => 0);
has db => ( is => "rw", isa => "Str", required => 0);
has zero => ( is => "rw", isa => "Bool", required => 0, default => sub { 0 } );
has matchtime => ( is => "rw", isa => "Int", required => 0, default => sub { 300 } );
has updateloved => ( is=> "rw", isa => "Bool", required => 0, default => sub { 0 } );
has lovedrating => ( is => "rw", isa => "Int", required => 0, default => sub { 5 } );
# has _config => ( is => "rw", lazy_build => 1, required => 0 );
has debug => ( is => "rw", isa => "Bool", default => sub{ 0 }, accessor => "debug" );
has conf => ( is => "rw", isa => "Str", required => 0, default => File::HomeDir::my_home()."/.config/banshee-1/lastfm_sync.conf" );

__PACKAGE__->meta->make_immutable;
binmode STDOUT, ":utf8";

#
# builders
#
sub _build_config {
	my $self = shift;

	lastfm_config(
		api_key => $self->key,
		secret => $self->secret
	);
}

=item backup
	create backup of database
=cut
sub backup {
	my ( $self ) = @_;

	my $cfg;
	my $bdb;
	if (-e $self->conf) {
		$cfg = new Config::Simple($self->conf);
		$bdb = ($self->db ? $self->db : $cfg->param('db'));
	} else {
		$cfg = new Config::Simple(syntax=>'ini');
		$bdb = ($self->db ? $self->db : File::HomeDir::my_home()."/.config/banshee-1/banshee.db");
		$cfg->param('db',$bdb);
	}
	#
	# check if database file exists
	#
	unless( -f $bdb ) {
		say "Database file ${\$bdb} doesn't exists";
		exit(1);
	}

	#
	# just copy file with .backup postfix
	#
	my $backup = sprintf "%s.backup", $bdb;
	copy( $bdb, $backup );
	say "Creating backup $backup";
}

sub sync {
	my( $self ) = @_;

	#
	# allow only rating from 1 to 5
	#
	unless ( $self->lovedrating >= 1 && $self->lovedrating <= 5 ) {
		say "Invalid rating '${\$self->lovedrating}'. A value from 1 to 5 is required.";
		exit(1);
	}

	#
	# only tracks with 0 playcount
	#
	my $zero  = "";
	$zero = "AND t.PlayCount = 0" if( $self->zero );

	#
	# independent counter
	#
	my $counter = 1;
	my $total   = 0;
	my $changed = 0;

	#
	# DateTime parser for comparing LastPlayed dates
	#
	my $epoch_startdt = DateTime->new( year => 1970, month => 1, day => 1 );
	my $epoch_parser = DateTime::Format::Epoch->new(epoch => $epoch_startdt);
	my $local_time_zone = DateTime::TimeZone->new( name => 'local' )->name();

	#
	# Read config file to determine when sync was previously run.
	# We only want to sync tracks scrobbled since the last sync.
	#
	my $cfg;
	my $last_update;
	my $bdb;
	my $username;
	my $limit = 250;

	if (-e $self->conf) {
		say "Loading configuration from " . $self->conf . "\n" if $self->debug;
		$cfg = new Config::Simple($self->conf);
		$last_update = $cfg->param('last_update');
		$username = ($self->username ? $self->username : $cfg->param('username'));
		$bdb = ($self->db ? $self->db : $cfg->param('db'));
		$limit = ($cfg->param('limit') ? $cfg->param('limit') : $limit);
		say "Last synced on " . $epoch_parser->parse_datetime($last_update)->ymd . "\n" if $self->debug;
	} else {
	# Create a new config file
		$cfg = new Config::Simple(syntax=>'ini');

		$last_update = 0;
		$cfg->param('last_update',$last_update);

		$username = $self->username;
		$cfg->param('username',$username);

		$bdb = ($self->db ? $self->db : File::HomeDir::my_home()."/.config/banshee-1/banshee.db");
		$cfg->param('db',$bdb);

		$cfg->param('limit',$limit);
	}
	if (!$username) {
		say "Error: user name not specified.\n";
		exit(1);
	}

	#
	# check if database file exists
	#
	unless( -f $bdb ) {
		say "Database file ${\$bdb} doesn't exists";
		exit(1);
	}

	#
	# iterate on track
	#
	my $dbh = DBI->connect( sprintf("dbi:SQLite:dbname=%s", $bdb ) , "", "" );
	$dbh->{sqlite_unicode} = 1;

	#
	# count affected rows for progress bar, let me know if You know any other way
	#
	my $sth = $dbh->prepare( qq{
		SELECT
			count( * ) AS count
		FROM
			CoreTracks t,
			CoreArtists a,
			CorePrimarySources s
		WHERE
			t.ArtistID = a.ArtistID AND
			t.PrimarySourceID = s.PrimarySourceID AND
			s.StringID = 'MusicLibrarySource-Library'
			$zero
	} );
	$sth->execute;
	$total = $sth->fetchrow_hashref()->{ "count" };
	$sth->finish;

	say "Found $total tracks to process";

	#
	# real query
	#
	$sth = $dbh->prepare( qq{
		SELECT
			*,
			t.Rating AS TrackRating
		FROM
			CoreTracks t,
			CoreArtists a,
			CorePrimarySources s
		WHERE
			t.ArtistID = a.ArtistID AND
			t.PrimarySourceID = s.PrimarySourceID AND
			s.StringID = 'MusicLibrarySource-Library'
			$zero
		ORDER BY
			TrackID
	} );
	$sth->execute();

	#
	# get scrobbled tracks
	#
	say "Fetching Last.fm scrobbled tracks." if $self->debug;
	my $libResponse = undef;
	my $libCounter = 0;
	try {
		$libResponse = lastfm_iter(
			"user.getRecentTracks",
			user => $username,
			limit => $limit,
			from => $last_update
		);
	};

	if ( !$libResponse ) {
		say "Error: Could not fetch Last.fm user library.";
		exit(1);
	}

	my $total_scrobbles = $Net::LastFMAPI::last_response->{"recenttracks"}->{"\@attr"}->{"total"};
	say "Total scrobbled tracks since last sync: $total_scrobbles \n";

	if (!$total_scrobbles) {
		say "Nothing to do. Exiting.\n";
		exit(0);
	}

	my $libProgress = Term::ProgressBar->new( { count => $Net::LastFMAPI::last_response->{"recenttracks"}->{"\@attr"}->{"total"}, name => "Fetching Last.fm library", ETA => "linear" } );

	my $libTracks = {};

	#
	# Main loop through scrobbled tracks
	#
	my $track_count = 0;
	while ( my $libTrack = $libResponse->() ) {
		my $artist = $libTrack->{"artist"}->{"#text"};
		my $track = $libTrack->{"name"};


		my $play_date;
		# Only process the track if it has a date associated with it (ignore now playing)
		if ($libTrack->{"date"}) {
			$track_count++;
			$libTracks->{lc $artist}->{lc $track}->{"playcount"}++;
			my $this_track_date = DateTime::Format::DateParse->parse_datetime($libTrack->{"date"}->{"#text"});
			$this_track_date->set_time_zone('UTC');
			$this_track_date->set_time_zone($local_time_zone);
			$play_date = $epoch_parser->format_datetime($this_track_date);

			# add the lastplayed date to the list of play dates for the track
			push(@{$libTracks->{lc $artist}->{lc $track}->{"lastplayed"}},$play_date);

			$libProgress->update($libCounter++);
		}
	}
	say "Tracks processed: " . $track_count . "\n" if $self->debug;

	#
	# Fetch loved tracks list
	#
	if ( $self->updateloved ) {
		say "Fetching Last.fm loved tracks..." if $self->debug;
		my $lovedResponse = undef;
		my $lovedCounter = 0;
		try {
			$lovedResponse = lastfm_iter(
				"user.getLovedTracks",
				user => $username,
				limit => 250
			);
		};

		if ( !$lovedResponse ) {
			say "Error: Could not fetch Last.fm loved tracks.";
			exit(1);
		}

		my $lovedProgress = Term::ProgressBar->new( { count => $Net::LastFMAPI::last_response->{"lovedtracks"}->{"\@attr"}->{"total"}, name => "Fetching Last.fm loved tracks", ETA => "linear" } );

		while ( my $libTrack = $lovedResponse->() ) {
			my $artist = $libTrack->{"artist"}->{"name"};
			my $track = $libTrack->{"name"};

			$libTracks->{lc $artist}->{lc $track}->{"loved"} = 1;

			$lovedProgress->update($lovedCounter++);
		}
	}

	my $progress = Term::ProgressBar->new( { count => $total, name => "checked", ETA => "linear" } );

	$dbh->do('BEGIN TRANSACTION');

	while( my $row = $sth->fetchrow_hashref ) {
		my $trackInfo = defined $row->{ "Name" } && defined $row->{ "Title" } ? 
			$libTracks->{ lc $row->{ "Name" } }->{ lc $row->{ "Title" }  } 
			: '';

		#
		# check if there is match
		#
		if( ref $trackInfo eq "HASH" ) {
			my $track_changed = 0;

			my $setFields = '';

			my $lastfm_count = $trackInfo->{ "playcount"};
			unless( is_int( $lastfm_count ) ) {
				$lastfm_count = 0;
			}

			my $new_playcount = $row->{"PlayCount"};
			while (my $playdate = shift(@{$trackInfo->{"lastplayed"}})) {
				my $lib_lastplayed = ($row->{"LastPlayedStamp"} ? $row->{"LastPlayedStamp"} : 0);
				# Don't increment if the play date is approximately equal (within $self->matchtime seconds) to the last played date to prevent double counting tracks scrobbled from banshee
				if (abs($playdate - $lib_lastplayed) > $self->matchtime) {
					$setFields = $setFields . ($setFields ? ", " : '') .
					"LastPlayedStamp = " . $playdate;
					$new_playcount++;
				}
			}
			if ($new_playcount > $row->{"PlayCount"}) {
				say "\tUpdating play count to $new_playcount.";
				$setFields = $setFields . sprintf( ($setFields ? ", " : '') . "PlayCount = %d",
					$new_playcount
				);
				$track_changed = 1;
			}
			
			my $lastfm_loved = $trackInfo->{ "loved"};
			unless ( is_int( $lastfm_loved) ) {
				$lastfm_loved = 0;
			}

			say "Found track $counter (${\$row->{TrackID}}) with ${ \$row->{ Name }}:${\$row->{ Title }}, play count: ${\$row->{ PlayCount}}, rating: ${\$row->{ TrackRating}}" if $self->debug;
			say "Last.fm match is ${\$row->{Name}}:${\$row->{Title}}, play count: $lastfm_count, loved: $lastfm_loved" if $self->debug;


			#
			# add 5 stars for a loved track if rating not set
			#
			if ( $lastfm_loved eq 1 && $row->{ "TrackRating"} eq 0 ) {
				say "\tBanshee unrated song is loved" if $self->debug;
				$setFields = $setFields . sprintf( ($setFields ? ", " : '') . "Rating = %d",
					$self->lovedrating
				);
			}

			if ( $setFields ) {
				print "\tUpdating track... " if $self->debug;
				#
				#
				#
				$dbh->do( sprintf("UPDATE CoreTracks SET ${setFields} WHERE TrackID = %d",
					$row->{ "TrackID"}
				) );
				$track_changed = 1;
				say "done." if $self->debug;

			}

			if ( $track_changed eq 1 ) {
				$changed++;
			}

			say "done." if $self->debug;
		}
		$progress->update( $counter++ );
	}

	$dbh->do('COMMIT TRANSACTION');
	$dbh->disconnect();
	say "Updated $changed tracks of $total total tracks";
	
	#
	# Update config file with current datetime
	#
	$cfg->param('last_update',$epoch_parser->format_datetime(DateTime->now()));
	$cfg->write($self->conf);
}

no Moose;
1;

package main;

use common::sense;
=pod cmndline

--key=b25b959554ed76058ac220b7b2e0a026 --username=<lastfm-username>

=cut

my $client = Banshee::LastFm::Sync->new_with_options();
$client->backup();
$client->sync;

1;

#vim:set filetype=perl noexpandtab softtabstop=0
